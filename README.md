# cp_team_4
# Звіт

Наша команда обрала тему під №1, а саме: «Пошук найкоротшого шляху між двома точками поверхні». Використовуючи знання, здобуті на курсі дискретної математики під час вивчення теми “Графи та їх властивості”, було реалізовано алгоритм Дейкстри для пошуку найкоротшого шляху між двома точками  прямокутної ділянки певного ландшафту.
Під час розробки програми, було створено 4 функції:**read_file**, **make_a_square**, **distance**, **dijkstra**.

## Функція read_file:
Ця функція приймає шлях до файлу і зчитує його вміст, перебираючи всі рядки у файлі і розбиваючи їх на окремі елементи за допомогою split(). Після цього ці значення перетворюються на десяткові числа і додаються до списку. Функція вертає список списків.

## Функція make_a_square:
Ця функція перетворює прямокутний масив у квадратний. Приймає список списків. Якщо кількість списків є більша за кількість елементів в одного із цих списків, то до других додається необхідна кількість нескінченностей. Якщо ж цих елементів є більше, то до списку додаються списку, які складаються із нескінченностей необхідної кількості. Якщо ж масив заданий одразу квадратом, то вертає його назад.

## Функція distance:
Приймає список списків. У цій функції ми обчислюємо відстань між двома точками в графі, що вивели у функції make_a_square. Спершу ми ітеруємо по значеннях списку й знаходимо відстані між двома точками,враховуючи їхні висоти. Додаємо у новий список списки із 2 точок і відстані між ними. Після цього ми перетворюємо список на словник, де ключем є точка, а значенням є список списків, у яких вказана інша точка і відстань до неї.

## Функція dijkstra:
Ця функція реалізовує вже сам алгоритм Дейкстри, що є найголовнішим етапом в розробці. Функція приймає три значення: словник, що ми отримали з функції distance, початкова точка та кінцева точка. Алгоритм починається циклом за допомогою якого ми приписуємо нескінченну відстань для будь-якої точки від початкової. Далі за допомогою циклу while, ми ітеруємо усі точки, які ще не є відвіданими та встановлюємо відстань до них, якщо поточна точка ще не визначена або відстань до неї менша за поточну мінімальну відстань ми присвоюємо поточній точці статус - мінімальної точки. Тоді ми створюємо список у який входять всі можливі шляхи до поточної точки. Якщо сума поточного шляху та відстань до поточної точки менша за відстань до наступної точки, то ми оновлюємо відстань до наступної точки, оголошуємо, що вона є попередником для наступної точки. Після цього ми видаляємо поточну точку зі списку точок, які ми вже відвідали. Цикл продовжується доки у нас є невідвідані точки. Далі ми створюємо наступний цикл, у якому ми спершу вставляємо поточну точку в початок шляху та оголошуємо її попередником до поточної точки. Цикл продовжується доки поточна точка не дорівнює початковій. Останнім кроком ми вставляємо початкову точку на початок шляху. В кінці ми виводимо результат: найкоротшу відстань та шлях, у вигляді індексів точок, від початкової точки до кінцевої.

## Тепер трішки про етапи проробленої роботи: 
Спершу ми зібралися командою, обдумали завдання, яке стоїть перед нами та пересвідчилися, що всі члени команди розуміють, що нам потрібно зробити. Потім ми розподілили роботу між усіма учасниками.  

### Розподіл роботи відбувся таким чином:
Функція read_file() - Оля Гаврилюк

Функція make_a_squar() - Артур Пельчарський, Юрій Логін

Функція distance() - Уляна Матвісів

Функція dijkstra() - Артур Пельчарський, Юрій Логін

Звіт до проєкту - Оля Гаврилюк, Уляна Матвісів

Презентація до проєкту - Арсеній Заводнік

Впродовж усього часу ми активно допомагали одне одному, а ще детальніше розібралися з тим як працює алгоритм пошуку найкоротшого шляху. Виконання проекту для нас стало нелегким, проте цікавим процесом, ми усі набули нового досвіду. 
